<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ringpara</title>
  <meta name="keywords" content="ringpara">
  <meta name="description" content="rp = ringpara, use global THERING">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">atmat</a> &gt; <a href="../index.html">pubtools</a> &gt; <a href="index.html">global_lattice_params</a> &gt; ringpara.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for atmat/pubtools/global_lattice_params&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>ringpara
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>rp = ringpara, use global THERING</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function rp = ringpara(THERING,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">rp = ringpara, use global THERING
rp = ringpara(THERING)
rp = ringpara(THERING,U0), supply total radiation loss in MeV
calculate various ring parameters
(1) The calculation of emittance, mcf, momentum spread, bunch length, damping time, etc 
is more accurate than atsummary.m because detailed
calculation of dispersion function and curly H function inside dipoles is performed. 
(2) calculate contribution of dispersion to vertical emittance.

Author: Xiaobiao Huang
created on 12/17/2007
Part of this code was modified from atsummary.m

Modified by Peace Chang (check if theta(ii) ~= 0.0)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="nus.html" class="code" title="function Nus = nus (VrfMV, alpha, U0MeV, E0MeV, h)">nus</a>	this function return the synchrotron tune</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="drf.html" class="code" title="function delta_max_rf=drf(ring,Vrf) %#ok<INUSD>">drf</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [dI1,dI2,dI3,dI4,dI5,curHavg] = calcRadInt(rho,theta, a0,b0,D0,D0p,K1,th1,th2)</a></li><li><a href="#_sub2" class="code">function [Dx, Dxp] = calcdisp(rho, theta, D0, D0p, K1)</a></li><li><a href="#_sub3" class="code">function [ax, bx] = calctwiss(rho, theta, a0, b0, K1)</a></li><li><a href="#_sub4" class="code">function Mx = calcMx(rho,K1,theta)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function rp = ringpara(THERING,varargin)</a>
0002 <span class="comment">%rp = ringpara, use global THERING</span>
0003 <span class="comment">%rp = ringpara(THERING)</span>
0004 <span class="comment">%rp = ringpara(THERING,U0), supply total radiation loss in MeV</span>
0005 <span class="comment">%calculate various ring parameters</span>
0006 <span class="comment">%(1) The calculation of emittance, mcf, momentum spread, bunch length, damping time, etc</span>
0007 <span class="comment">%is more accurate than atsummary.m because detailed</span>
0008 <span class="comment">%calculation of dispersion function and curly H function inside dipoles is performed.</span>
0009 <span class="comment">%(2) calculate contribution of dispersion to vertical emittance.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%Author: Xiaobiao Huang</span>
0012 <span class="comment">%created on 12/17/2007</span>
0013 <span class="comment">%Part of this code was modified from atsummary.m</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%Modified by Peace Chang (check if theta(ii) ~= 0.0)</span>
0016 
0017 <span class="keyword">if</span> nargin==0
0018     <span class="keyword">global</span> THERING;
0019 <span class="keyword">end</span>
0020 Cq = 3.83E-13; 
0021 a = findcells(THERING,<span class="string">'Energy'</span>);
0022 <span class="keyword">if</span> isempty(a);
0023    gamma = 3000/.511;
0024 <span class="keyword">else</span>
0025    gamma = THERING{a(1)}.Energy/.511E6; 
0026 <span class="keyword">end</span>
0027 
0028 dpindex = findcells(THERING,<span class="string">'BendingAngle'</span>);
0029 [tw,tune,chrom] = twissring(THERING,0,dpindex,<span class="string">'chrom'</span>,0.00001);
0030 beta = cat(1, tw.beta);
0031 alpha = cat(1, tw.alpha);
0032 mu = cat(1, tw.mu);
0033 disper = cat(1, tw.Dispersion);
0034 Dx  = disper(1:4:end);
0035 Dxp = disper(2:4:end);
0036 Dy  = disper(3:4:end);
0037 Dyp = disper(4:4:end);
0038 
0039 [tmptw,tune,chrom] = twissring(THERING,0,1:length(THERING),<span class="string">'chrom'</span>,0.00001);
0040 
0041 lendp = getcellstruct(THERING,<span class="string">'Length'</span>,dpindex); <span class="comment">%bending magnet length</span>
0042 theta = getcellstruct(THERING,<span class="string">'BendingAngle'</span>,dpindex); <span class="comment">%bending angle</span>
0043 rho = lendp./theta;<span class="comment">%THERING{dpindex(1)}.Length/THERING{dpindex(1)}.BendingAngle;</span>
0044 
0045 I1 = 0;
0046 I2 = 0;
0047 I3 = 0;
0048 I4 = 0;
0049 I5 = 0;
0050 <span class="keyword">for</span> ii=1:length(dpindex)
0051   <span class="keyword">if</span> theta(ii) ~= 0.0
0052     <span class="keyword">if</span> isfield(THERING{dpindex(ii)},<span class="string">'K'</span>)
0053         K = THERING{dpindex(ii)}.K;
0054     <span class="keyword">else</span>
0055         K = 0;
0056     <span class="keyword">end</span>
0057     th1 = THERING{dpindex(ii)}.EntranceAngle;
0058     th2 = THERING{dpindex(ii)}.ExitAngle;
0059     [dI1,dI2,dI3,dI4,dI5,curHavg1(ii)] = <a href="#_sub1" class="code" title="subfunction [dI1,dI2,dI3,dI4,dI5,curHavg] = calcRadInt(rho,theta, a0,b0,D0,D0p,K1,th1,th2)">calcRadInt</a>(rho(ii),theta(ii), <span class="keyword">...</span>
0060          alpha(ii,1),beta(ii,1),Dx(ii),Dxp(ii),K,th1,th2);
0061     I1 = I1 + dI1;
0062     I2 = I2 + dI2;
0063     I3 = I3 + dI3;
0064     I4 = I4 + dI4;
0065     I5 = I5 + dI5;
0066   <span class="keyword">end</span>
0067 <span class="keyword">end</span>
0068 <span class="comment">% curHavg = sum(curHavg1.*lendp./abs(rho))/sum(lendp);</span>
0069 <span class="comment">% %emittx =  Cq*gamma^2*curHavg/Jx/rho*1e9; %nm-rad</span>
0070 <span class="comment">% emittx =  Cq*gamma^2*curHavg/Jx*1e9; %nm-rad</span>
0071 R = findspos(THERING, length(THERING)+1)/2/pi;
0072 alphac = I1/2/pi/R;
0073 U0 = 14.085*(gamma*.511/1000)^4*I2*1000.; <span class="comment">%eV</span>
0074 <span class="keyword">if</span> nargin&gt;=2
0075     fprintf(<span class="string">'dipole radiation loss:  %4.5f keV\n'</span>, U0/1000.);
0076     U0 = varargin{1}*1e6; <span class="comment">%convert MeV to eV</span>
0077 <span class="keyword">end</span>
0078 sigma_E = gamma*sqrt(Cq*I3/(2*I2+I4));
0079 Jx = 1-I4/I2;
0080 Jy = 1.00;
0081 Je = 2+I4/I2;
0082 emittx = Cq*gamma^2*I5/(I2-I4);
0083 
0084 cspeed = 2.99792458e8; <span class="comment">%m/s</span>
0085 T0 = 2*pi*R/cspeed;
0086 alpha0 = U0/1.0e6/2/T0/(gamma*.511);
0087 alphax = Jx*alpha0;  <span class="comment">%horizontal damping rate, 1/s</span>
0088 alphay = Jy*alpha0;
0089 alphaE = Je*alpha0;
0090 
0091 rp.E0 = gamma*0.511E6;
0092 rp.R = R;
0093 rp.alphac = alphac;
0094 rp.U0 = U0; <span class="comment">%eV</span>
0095 rp.sigma_E = sigma_E;
0096 rp.emittx = emittx;
0097 rp.T0 = T0;
0098 rp.integrals = [I1,I2,I3,I4,I5];
0099 rp.dampingalpha = [alphax, alphay, alphaE];
0100 rp.dampingtime = 1./[alphax, alphay, alphaE];
0101 rp.dampingJ = [Jx,Jy,Je];
0102 
0103 <span class="comment">%rp.tw = tw;</span>
0104 <span class="comment">%rp.tmptw = tmptw;</span>
0105 rp.tunes = tune;
0106 rp.chroms = chrom;
0107 rp.etac = 1/gamma^2-alphac;
0108 
0109 cavind = findcells(THERING,<span class="string">'HarmNumber'</span>);
0110 <span class="keyword">if</span> ~isempty(cavind)
0111     freq_rf = THERING{cavind(1)}.Frequency;
0112     harm = THERING{cavind(1)}.HarmNumber;
0113     Vrf = 0;
0114     <span class="keyword">for</span> ii=1:length(cavind)
0115         Vrf = Vrf+THERING{cavind(ii)}.Voltage;
0116     <span class="keyword">end</span>
0117 <span class="keyword">else</span>
0118     <span class="comment">% Default</span>
0119     fprintf(<span class="string">'warning: SPEAR3 rf parameters are assume\n'</span>);
0120     freq_rf = 476.314e6;
0121     harm = 372;
0122     Vrf = 3.2e6;
0123 <span class="keyword">end</span>
0124 
0125 phi_s = pi-asin(rp.U0/Vrf);
0126 <a href="nus.html" class="code" title="function Nus = nus (VrfMV, alpha, U0MeV, E0MeV, h)">nus</a> = sqrt(harm*Vrf*abs(rp.etac*cos(phi_s))/2/pi/rp.E0);
0127 rp.nus = <a href="nus.html" class="code" title="function Nus = nus (VrfMV, alpha, U0MeV, E0MeV, h)">nus</a>;
0128 rp.phi_s = phi_s;
0129 rp.harm = harm;
0130 rp.bunchlength = rp.sigma_E*rp.harm*abs(rp.etac)/rp.nus/2/pi/freq_rf*cspeed; <span class="comment">% rms bunchlength in meter</span>
0131 delta_max = sqrt(2*U0/pi/alphac/harm/rp.E0)*sqrt( sqrt((Vrf/U0).^2-1) - acos(U0./Vrf));
0132 rp.delta_max = delta_max;
0133 
0134 <span class="comment">%calculate vertical emittance</span>
0135 <span class="comment">%1. contribution of vertical dispersion</span>
0136 curVavg1 = 1./beta(:,2).*(Dy.^2 + (beta(:,2).*Dyp + alpha(:,2).*Dy).^2);
0137 curVavg = sum(curVavg1.*lendp./abs(rho))/sum(lendp);
0138 emitty_d = Cq*gamma^2*curVavg/Jy; <span class="comment">%m-rad</span>
0139 
0140 <span class="comment">% %2. contribution of linear coupling resonance</span>
0141 <span class="comment">% [G,Delta] = calc_lcG(THERING);</span>
0142 <span class="comment">% %emitty_c = emittx*abs(G)^2/(Delta^2+abs(G)^2);</span>
0143 <span class="comment">% emitty_c = emittx*abs(G)^2/Delta^2/2.0;</span>
0144 <span class="comment">% rp.emitty_c = emitty_c;</span>
0145 
0146 rp.emitty_d = emitty_d;
0147 <span class="comment">% rp.emitty = emitty_d + emitty_c;</span>
0148 
0149 <span class="keyword">if</span> nargout == 0
0150     fprintf(<span class="string">'\n'</span>);
0151     fprintf(<span class="string">'   ******** AT Ring Parmater Summary ********\n'</span>);
0152     fprintf(<span class="string">'   Energy: \t\t\t%4.5f [GeV]\n'</span>, rp.E0/1E9);
0153     fprintf(<span class="string">'   Circumference: \t\t%4.5f [m]\n'</span>, rp.R*2*pi);
0154     fprintf(<span class="string">'   Revolution time: \t\t%4.5f [ns] (%4.5f [MHz]) \n'</span>, rp.T0*1e9,1./rp.T0*1e-6);
0155     fprintf(<span class="string">'   Betatron tune H: \t\t%4.5f (%4.5f [kHz])\n'</span>, rp.tunes(1),(rp.tunes(1)-floor(rp.tunes(1)))/rp.T0*1e-3);
0156     fprintf(<span class="string">'                 V: \t\t%4.5f (%4.5f [kHz])\n'</span>, rp.tunes(2),(rp.tunes(2)-floor(rp.tunes(2)))/rp.T0*1e-3);
0157     fprintf(<span class="string">'   Momentum Compaction Factor: \t%4.5f\n'</span>, rp.alphac);
0158     fprintf(<span class="string">'   Chromaticity H: \t\t%+4.5f\n'</span>, rp.chroms(1));
0159     fprintf(<span class="string">'                V: \t\t%+4.5f\n'</span>, rp.chroms(2));
0160     fprintf(<span class="string">'   Synchrotron Integral 1: \t%4.5f [m]\n'</span>, rp.integrals(1));
0161     fprintf(<span class="string">'                        2: \t%4.5f [m^-1]\n'</span>, rp.integrals(2));
0162     fprintf(<span class="string">'                        3: \t%4.5f [m^-2]\n'</span>, rp.integrals(3));
0163     fprintf(<span class="string">'                        4: \t%4.5f [m^-1]\n'</span>, rp.integrals(4));
0164     fprintf(<span class="string">'                        5: \t%4.5f [m^-1]\n'</span>, rp.integrals(5));
0165     fprintf(<span class="string">'   Damping Partition H: \t%4.5f\n'</span>, rp.dampingJ(1));
0166     fprintf(<span class="string">'                     V: \t%4.5f\n'</span>, rp.dampingJ(2));
0167     fprintf(<span class="string">'                     E: \t%4.5f\n'</span>, rp.dampingJ(3));
0168     fprintf(<span class="string">'   Radiation Loss: \t\t%4.5f [keV]\n'</span>, rp.U0/1000.);
0169     fprintf(<span class="string">'   Natural Energy Spread: \t%4.5e\n'</span>, rp.sigma_E);
0170     fprintf(<span class="string">'   Natural Emittance: \t\t%4.5e [nm]\n'</span>, rp.emittx*1e9);
0171     fprintf(<span class="string">'   Radiation Damping H: \t%4.5f [ms]\n'</span>, rp.dampingtime(1)*1e3);
0172     fprintf(<span class="string">'                     V: \t%4.5f [ms]\n'</span>, rp.dampingtime(2)*1e3);
0173     fprintf(<span class="string">'                     E: \t%4.5f [ms]\n'</span>, rp.dampingtime(3)*1e3);
0174     fprintf(<span class="string">'   Slip factor : \t%4.5f\n'</span>, rp.etac);
0175     fprintf(<span class="string">'\n'</span>);
0176     fprintf(<span class="string">'   Assuming cavities Voltage: %4.5f [kV]\n'</span>, Vrf/1e3);
0177     fprintf(<span class="string">'                   Frequency: %4.5f [MHz]\n'</span>, freq_rf/1e6);
0178     fprintf(<span class="string">'             Harmonic Number: %5d\n'</span>, rp.harm);
0179     fprintf(<span class="string">'   Synchronous Phase:  %4.5f [rad] (%4.5f [deg])\n'</span>, rp.phi_s, rp.phi_s*180/pi);
0180     fprintf(<span class="string">'   Linear Energy Acceptance:  %4.5f %%\n'</span>, rp.delta_max*100);
0181     fprintf(<span class="string">'   Synchrotron Tune:   %4.5f (%4.5f kHz or %4.2f turns) \n'</span>, rp.nus, rp.nus/rp.T0*1e-3, 1/rp.nus);
0182     fprintf(<span class="string">'   Bunch Length:       %4.5f [mm], %4.5f [ps]\n'</span>, rp.bunchlength*1e3, rp.bunchlength/cspeed*1e12);
0183     fprintf(<span class="string">'\n'</span>);
0184 <span class="comment">%     fprintf('   Vertical Emittance:  %4.5f [nm]\n', rp.emitty*1e9);</span>
0185 <span class="comment">%     fprintf('   Emitty from Dy:  %4.5f [nm], from linear coupling: %4.5f\n', rp.emitty_d*1e9,rp.emitty_c*1e9);</span>
0186     fprintf(<span class="string">'   Emitty from Dy:  %4.5f [nm]\n'</span>, rp.emitty_d*1e9);
0187 <span class="keyword">end</span>
0188 
0189 
0190 <a name="_sub1" href="#_subfunctions" class="code">function [dI1,dI2,dI3,dI4,dI5,curHavg] = calcRadInt(rho,theta, a0,b0,D0,D0p,K1,th1,th2)</a>
0191 <span class="comment">%[dI1,dI2,dI3,dI4,dI5,curHavg] = calcRadInt(rho,theta, a0,b0,D0,D0p,K1)</span>
0192 <span class="comment">%calcuate the contribution to the radiation integrals of a dipole.</span>
0193 <span class="comment">%rho, theta, radius and angle of the dipole</span>
0194 <span class="comment">%a0, b0, are horizontal alpha and beta at the entrance of the dipole,</span>
0195 <span class="comment">%D0, D0p are dispersion at the entrace of the dipole</span>
0196 <span class="comment">%K1, the gradient parameter in AT's convention, i.e., positive for</span>
0197 <span class="comment">%horizontal focusing, K1=0 by default</span>
0198 <span class="comment">%th1, th2, the entrance and exit angle, respectively, th1=th2=theta/2 by</span>
0199 <span class="comment">%default.</span>
0200 <span class="comment">%</span>
0201 
0202 <span class="keyword">if</span> nargin==6
0203    K1=0; 
0204 <span class="keyword">end</span>
0205 <span class="keyword">if</span> nargin&lt;9
0206    th1 = 0; <span class="comment">%theta/2.0;</span>
0207    th2 = 0; <span class="comment">%theta/2.0;</span>
0208 <span class="keyword">end</span>
0209 
0210 M21 = tan(th1)/rho;
0211 D0p = M21*D0+D0p;
0212 a0 = -M21*b0+a0;
0213 
0214 N = 100;
0215 th = (0:N)/N*theta;
0216 <span class="keyword">for</span> ii=1:length(th)
0217        [Dx(ii), Dxp(ii)] = <a href="#_sub2" class="code" title="subfunction [Dx, Dxp] = calcdisp(rho, theta, D0, D0p, K1)">calcdisp</a>(rho, th(ii), D0, D0p, K1);
0218        [ax, bx] = <a href="#_sub3" class="code" title="subfunction [ax, bx] = calctwiss(rho, theta, a0, b0, K1)">calctwiss</a>(rho, th(ii), a0, b0, K1);
0219        curHavg1(ii) = (Dx(ii)^2+(ax*Dx(ii)+bx*Dxp(ii))^2)/bx;
0220 <span class="keyword">end</span>
0221 curHavg = ((curHavg1(1)+curHavg1(end))/2.0 + sum(curHavg1(2:end-1)))/(length(th)-1);
0222 
0223 dI1 = ((Dx(1) + Dx(end))/2.0 + sum(Dx(2:end-1)))*theta/N;
0224 dI2 = abs(theta/rho);
0225 dI3 = abs(theta/rho^2);
0226 dI4 = (1/rho^2 + 2*K1)*dI1  - (Dx(1)/rho^2*tan(th1) + Dx(end)/rho^2*tan(th2));
0227 dI5 = curHavg*abs(theta/rho^2);
0228 
0229 <a name="_sub2" href="#_subfunctions" class="code">function [Dx, Dxp] = calcdisp(rho, theta, D0, D0p, K1)</a>
0230 <span class="comment">%calcualte dispersion function inside a combined-function dipole</span>
0231 s = rho*theta;
0232 <span class="keyword">if</span> K1&gt;-1/rho^2; <span class="comment">%horizontal focusing</span>
0233     sqK = sqrt(1/rho^2+K1);
0234     Dx =  D0*cos(sqK*s) + D0p/sqK*sin(sqK*s)+(1-cos(sqK*s))/rho/sqK^2;
0235     Dxp = -D0*sqK*sin(sqK*s)+D0p*cos(sqK*s)+sin(sqK*s)/rho/sqK;
0236 <span class="keyword">else</span> <span class="comment">%horizontal defocusing</span>
0237     sqK = sqrt(-(1/rho^2+K1));
0238     Dx =  D0*cosh(sqK*s) + D0p/sqK*sinh(sqK*s)+(-1+cosh(sqK*s))/rho/sqK^2;
0239     Dxp = D0*sqK*sinh(sqK*s)+D0p*cosh(sqK*s)+sinh(sqK*s)/rho/sqK;
0240 
0241 <span class="keyword">end</span>
0242 
0243 <a name="_sub3" href="#_subfunctions" class="code">function [ax, bx] = calctwiss(rho, theta, a0, b0, K1)</a>
0244 <span class="comment">%calculate twiss function inside a combined-function dipole manget</span>
0245 Mx = <a href="#_sub4" class="code" title="subfunction Mx = calcMx(rho,K1,theta)">calcMx</a>(rho, K1,theta);
0246 g0 = (1+a0^2)/b0;
0247 twx2 = [Mx(1,1)^2, -2*Mx(1,1)*Mx(1,2), Mx(1,2)^2; 
0248     -Mx(1,1)*Mx(2,1), Mx(1,1)*Mx(2,2)+Mx(1,2)*Mx(2,1),-Mx(1,2)*Mx(2,2);
0249     Mx(2,1)^2, -2*Mx(2,1)*Mx(2,2),Mx(2,2)^2] * [b0, a0, g0]';
0250 ax = twx2(2);
0251 bx = twx2(1);
0252 
0253 <a name="_sub4" href="#_subfunctions" class="code">function Mx = calcMx(rho,K1,theta)</a>
0254 s = rho*theta;
0255 <span class="keyword">if</span> K1&gt;-1/rho^2; <span class="comment">%horizontal focusing</span>
0256     sqK = sqrt(1/rho^2+K1);
0257     Mx = [cos(sqK*s), sin(sqK*s)/sqK; -sqK*sin(sqK*s), cos(sqK*s)];
0258 <span class="keyword">else</span> <span class="comment">%horizontal defocusing</span>
0259     sqK = sqrt(-(1/rho^2+K1));
0260     Mx = [cosh(sqK*s), sinh(sqK*s)/sqK; sqK*sinh(sqK*s), cosh(sqK*s)];
0261 <span class="keyword">end</span>
0262</pre></div>
<hr><address>Generated on Sun 28-Jul-2013 23:18:56 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>