<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of addsshift</title>
  <meta name="keywords" content="addsshift">
  <meta name="description" content="ADDSSHIFT will translate the element along the 's' vector by extending">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">atmat</a> &gt; <a href="../../index.html">pubtools</a> &gt; <a href="../index.html">misalignment</a> &gt; <a href="index.html">additional_AT_functions</a> &gt; addsshift.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for atmat/pubtools/misalignment/additional_AT_functions&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>addsshift
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>ADDSSHIFT will translate the element along the 's' vector by extending</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function addsshift(elemindex, ds) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ADDSSHIFT will translate the element along the 's' vector by extending
 and contracting drifts that exist on either side of the element. If there
 are other nondrift elements beside the elements (eg split elements) there
 will be an error and the user will be prompted to check the element they
 wish to move and ensure that it has adjacent drifts (ie space to move).
 The program will prescan &quot;elemindex&quot; and will group elements if the
 indices are sequential. Example: 1 3 5 6 8 10 -&gt; will be grouped such
 that 5 and 6 are considered a single element.

 !!! WARNING !!! In order to undo the changes one has to reload to lattice
 file as the shifts are not stored here and will not know what to do to
 undo the length changes. If using the misalignment tools then the
 UNDOMISALIGN function should be able to undo the changes that were
 applied to it.

 See also <a href="addxrot.html" class="code" title="function addxrot(elemindex, theta)">ADDXROT</a>, <a href="addyrot.html" class="code" title="function addyrot(elemindex, theta)">ADDYROT</a>, <a href="addsrot.html" class="code" title="function addsrot(elemindex, theta)">ADDSROT</a>, <a href="addshift.html" class="code" title="function addshift(ELEMINDEX, DX, DY)">ADDSHIFT</a>, <a href="setxrot.html" class="code" title="function setxrot(elemindex, theta)">SETXROT</a>, <a href="setyrot.html" class="code" title="function setyrot(elemindex, theta)">SETYROT</a>, <a href="setsrot.html" class="code" title="">SETSROT</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function addsshift(elemindex, ds)</a>
0002 <span class="comment">% ADDSSHIFT will translate the element along the 's' vector by extending</span>
0003 <span class="comment">% and contracting drifts that exist on either side of the element. If there</span>
0004 <span class="comment">% are other nondrift elements beside the elements (eg split elements) there</span>
0005 <span class="comment">% will be an error and the user will be prompted to check the element they</span>
0006 <span class="comment">% wish to move and ensure that it has adjacent drifts (ie space to move).</span>
0007 <span class="comment">% The program will prescan &quot;elemindex&quot; and will group elements if the</span>
0008 <span class="comment">% indices are sequential. Example: 1 3 5 6 8 10 -&gt; will be grouped such</span>
0009 <span class="comment">% that 5 and 6 are considered a single element.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% !!! WARNING !!! In order to undo the changes one has to reload to lattice</span>
0012 <span class="comment">% file as the shifts are not stored here and will not know what to do to</span>
0013 <span class="comment">% undo the length changes. If using the misalignment tools then the</span>
0014 <span class="comment">% UNDOMISALIGN function should be able to undo the changes that were</span>
0015 <span class="comment">% applied to it.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% See also ADDXROT, ADDYROT, ADDSROT, ADDSHIFT, SETXROT, SETYROT, SETSROT</span>
0018 
0019 <span class="keyword">global</span> THERING FAMLIST
0020 
0021 <span class="comment">% Elemindex and ds have to be the same size</span>
0022 <span class="keyword">if</span> length(elemindex) ~= length(ds)
0023     disp(<span class="string">'Number of elements and number of shifts are not the same'</span>);
0024     disp(<span class="string">'Nothing done'</span>);
0025     <span class="keyword">return</span>
0026 <span class="keyword">end</span>
0027 
0028 <span class="comment">% Find and group sequential elements</span>
0029 ind = [];
0030 <span class="keyword">if</span> length(elemindex) &gt; 1
0031     temp = elemindex(2:end) - elemindex(1:end-1);
0032     ind = find(temp &lt; 2);
0033 <span class="keyword">end</span>
0034 
0035 <span class="comment">% Check that sequential elements are being shifted by the same amount.</span>
0036 <span class="keyword">for</span> i=1:length(ind)
0037     <span class="keyword">if</span> ds(ind(i)) ~= ds(ind(i)+1)
0038         disp(<span class="string">'Two sequential elements (ie no drift between them) are moved by different amounts.'</span>)
0039         disp(<span class="string">'!! This cannot be done !!'</span>);
0040         disp([<span class="string">' -&gt; take a look at element index: '</span> num2str(ind(i)) <span class="string">' and '</span> num2str(ind(i) + 1)]);
0041         <span class="keyword">return</span>
0042     <span class="keyword">end</span>
0043 <span class="keyword">end</span>
0044 
0045 <span class="comment">% Index the &quot;front&quot; and &quot;back&quot; element and check that they are drifts</span>
0046 
0047 
0048 
0049 
0050 <span class="keyword">return</span>
0051 frontdrift = 0;
0052 backdrift = 0;
0053 <span class="keyword">for</span> i=1:length(elemindex)
0054     currel = elemindex(i);
0055 
0056     <span class="comment">% Find first drift in front of element</span>
0057     ind = currel;
0058     <span class="keyword">while</span> frontdrift == 0
0059         <span class="keyword">if</span> isempty(regexpi(THERING{ind}.PassMethod,<span class="string">'drift'</span>)) | THERING{ind}.Length == 0
0060             <span class="comment">% Assume circular ring</span>
0061             <span class="keyword">if</span> ind == length(THERING)
0062                 ind = 1;
0063             <span class="keyword">else</span>
0064                 ind = ind + 1;
0065             <span class="keyword">end</span>
0066         <span class="keyword">else</span>
0067             frontdrift = ind;
0068         <span class="keyword">end</span>
0069     <span class="keyword">end</span>
0070 
0071     <span class="comment">% Find first drift behind the element</span>
0072     ind = currel;
0073     <span class="keyword">while</span> backdrift == 0
0074         <span class="keyword">if</span> isempty(regexpi(THERING{ind}.PassMethod,<span class="string">'drift'</span>)) | THERING{ind}.Length == 0
0075             <span class="comment">% Assume circular ring</span>
0076             <span class="keyword">if</span> ind == 1
0077                 ind = length(THERING);
0078             <span class="keyword">else</span>
0079                 ind = ind - 1;
0080             <span class="keyword">end</span>
0081         <span class="keyword">else</span>
0082             backdrift = ind;
0083         <span class="keyword">end</span>
0084     <span class="keyword">end</span>
0085 
0086     THERING{backdrift}.Length = THERING{backdrift}.Length + ds(i);
0087     THERING{frontdrift}.Length = THERING{frontdrift}.Length + ds(i);
0088 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 28-Jul-2013 23:18:56 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>